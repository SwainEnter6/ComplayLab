<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <link rel="stylesheet" href="seungmok.css">
</head>
<body>

    <div class="fdiv1">
        <img src="./imgs/main.png" alt="mainimg">
    </div>

    <div class="fdiv2">
        <div>
            <img class = "lemon" src="./imgs/lemon.png">
        </div>
    </div>

    <div class="fdiv3">
        <div class="mouse-container">
            <div class="container"></div>
            <div class="container"></div>
            <div class="container"></div>
            <div class="container"></div>
        </div>
        <div class="container">
            <img src="./imgs/arrowleft2.jpg" class="draggable" draggable="true">
            <img src="./imgs/arrowright2.jpg" class="draggable" draggable="true">
        </div>
    </div>

    <!-- <script>
    const draggables = document.querySelectorAll(".draggable"); 
    //클래스가 "draggable"인 모든 요소를 선택. 드래그 가능한 요소들을 나타냄.
    const containers = document.querySelectorAll(".container");
    //클래스가 "container"인 모든 요소를 선택. 드래그 가능한 요소를 포함하는 컨테이너를 나타냄.

    draggables.forEach(draggable => { //각 드래그 가능한 요소에 대해 반복문을 실행.
        draggable.addEventListener("dragstart", () => { //"dragstart" 이벤트가 발생했을 때 실행할 함수를 지정.
            draggable.classList.add("dragging"); //"dragging" 클래스를 추가. 드래그 중임을 표시하는 데 사용.
    });

        draggable.addEventListener("dragend", () => { //"dragend" 이벤트가 발생했을 때 실행할 함수를 지정.
            draggable.classList.remove("dragging"); //"dragging" 클래스를 제거. 드래그 중이 아님을 표시하는 데 사용
        });
    });

    containers.forEach(container => {
        container.addEventListener("dragover", e => { //"dragover" 이벤트가 발생했을 때 실행할 함수를 지정.
            e.preventDefault(); //이벤트의 기본 동작을 중단시킴. 드래그 중인 요소를 컨테이너 위로 이동할 때 브라우저가 수행하는 기본 동작을 방지.
            const afterElement = getDragAfterElement(container, e.clientX); 
            //드래그 중인 요소가 컨테이너 내에서 어느 위치에 있는지를 결정하는 함수인 getDragAfterElement를 호출하여 해당 위치를 계산. e.clientX는 마우스의 x 좌표를 나타냄.
            const draggable = document.querySelector(".dragging");
            //현재 드래그 중인 요소를 선택. 드래그 중에만 해당 클래스를 가지고 있으므로, .dragging 선택자를 사용하여 선택됩니다.
            if (afterElement === undefined) { 
                //컨테이너 내에서 드래그 가능한 요소를 삽입할 위치를 결정하는데 사용되는 afterElement가 undefined인 경우를 확인. 드래그 가능한 요소를 컨테이너의 맨 끝에 추가.
                container.appendChild(draggable);
            }else if (afterElement !== draggable) { 
                container.insertBefore(draggable, afterElement.nextSibling); //draggable 요소를 afterElement의 다음 형제 요소로 삽입. 이를 통해 요소가 원하는 위치에 삽입.
            }
        });
    });

    function getDragAfterElement(container, x) {
        const draggableElements = [
            ...container.querySelectorAll(".draggable:not(.dragging)"),
        ];

        return draggableElements.reduce(
            (closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            },
            { offset: Number.NEGATIVE_INFINITY },
        ).element;
    }
    </script> -->
    <script>
        const draggables = document.querySelectorAll(".draggable");
        const containers = document.querySelectorAll(".container");
    
        draggables.forEach(draggable => {
            draggable.addEventListener("dragstart", () => {
                draggable.classList.add("dragging");
            });
    
            draggable.addEventListener("dragend", () => {
                draggable.classList.remove("dragging");
            });
        });
    
        containers.forEach(container => {
            container.addEventListener("dragover", e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(container, e.clientX);
                const draggable = document.querySelector(".dragging");
                const existingDraggable = container.querySelector(".draggable:not(.dragging)");
                if (!existingDraggable) {
                    if (afterElement === undefined) {
                        container.appendChild(draggable);
                    } else if (afterElement !== draggable) {
                        container.insertBefore(draggable, afterElement.nextSibling);
                    }
                }
            });
        });
    
        function getDragAfterElement(container, x) {
            const draggableElements = [
                ...container.querySelectorAll(".draggable:not(.dragging)"),
            ];
    
            return draggableElements.reduce(
                (closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = x - box.left - box.width / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                },
                { offset: Number.NEGATIVE_INFINITY },
            ).element;
        }
    </script>
</body>
</html>
